---
title: 数据结构和算法
date: 2021-10-24
categories: 
- Python
tags:
- Python Cookbook
---


根据 《Python Cookbook》 里**有趣或自身还不清楚**的部分简单总结，以便保存和查找。这将会是一个系列，每个文档对应书中一个章节  

# 从任意长度的可迭代对象中分解元素
用"\*表达式"实现，去掉一个列表中的第一个和最后一个元素，剩下的元素取平均值  
```
def drop_first_last(target):
	first, *middle, last = target
	return avg(middle)
```


# 保存最后 N 个元素
用 `collections.deque` ，`deque(maxlen=N)` 创建了一个固定长度的队列，当队列已满且有新纪录加入，会自动移除最老的那条记录
```
from collections import deque

q = deque(maxlen=3)
for i in range(5):
	q.append(i)
	if i == 2:
		print(q)  # deque([0, 1, 2], maxlen=3)
print(q)  # deque([2, 3, 4], maxlen=3)
```
虽然在列表上也可以手动完成这样的操作（`append`、`del`），但队列这种解决方案更加优雅，且运行速度也快得多  
如果不指定队列的大小，也就得到一个无界限的队列，可以在两端执行添加（`append`、`appendleft`）和弹出（`pop`、`popleft`）操作


# 找到最大或最小的 N 个元素
heapq 模块中有两个函数 `nlargest()` 和 `nsmallest()`
```
import heapq

nums = [1, 8, 7, -5, -27, 66, 34, 23, 0]
print(heapq.nlargest(3, nums))  # [66, 34, 23]
print(heapq.nsmallest(3, nums))  # [-27, -5, 0]
```
这两个函数可以接受一个参数 key，从而工作在更加复杂的数据结构上
```
import heapq

portfolio = [
    {"name": "A", "age": 10},
    {"name": "B", "age": 20},
    {"name": "C", "age": 13},
    {"name": "D", "age": 24},
    {"name": "E", "age": 6},
]
print(heapq.nlargest(3, portfolio, key=lambda s: s["age"]))  # [{'name': 'D', 'age': 24}, {'name': 'B', 'age': 20}, {'name': 'C', 'age': 13}]
print(heapq.nsmallest(3, portfolio, key=lambda s: s["age"]))  # [{'name': 'E', 'age': 6}, {'name': 'A', 'age': 10}, {'name': 'C', 'age': 13}]
```
如果寻找 N 个最大或最小的元素，且同集合中元素的总数目相比，N 很小，那么以下函数可以提供更好的**性能**，这些函数首先在顶层将数据转换成列表，且元素以堆的顺序排列
```
import heapq

nums = [1, 8, 7, -5, -27, 66, 34, 23, 0]
heap = list(nums)
heapq.heapify(heap)
print(heap)  # [-27, -5, 7, 0, 8, 66, 34, 23, 1]
```
堆最重要的特性就是 **`heap[0]` 总是最小那个的元素**。接下来的元素可依次通过 `heapq.heappop()` 找到。该方法会将第一个元素弹出，以第二个元素取而代之（该操作复杂度是 O(logN)，N 代表堆大小）
```
print(heapq.heappop(heap))  # -27
print(heapq.heappop(heap))  # -5
print(heapq.heappop(heap))  # -7
```
当要找的元素数量相对较小时，`nlargest()` 和 `nsmallest()` 是最适用的。如果只是简单地想找到最小或最大的元素，那么用 `max()` 和 `min()` 会更加快。如果 N 和集合本身大小差不多，通常更快的方法是堆集合排序，然后做切片操作（如：`sorted(items)[:N]` 或 `sorted(items)[N:]`）  
另外，`nlargest()` 和 `nsmallest()` 的实际实现会根据使用方式不同，可能会相应做出一些优化措施（如：当 N 的大小同输入大小接近时，就会采用排序的方法）


# 实现优先级队列
利用 heapq 模块实现一个简单的优先级队列，能够以给定的优先级对元素排序，且每次 pop 时都会返回优先级最高的元素
```
import heapq


class PriorityQueue:

    def __init__(self):
        self._queuq = []
        # 插入顺序，将有相同优先级的元素排序
        self._index = 0

    def push(self, item, priority):
    	# 权限越高，相反数越小，位于越前面
        heapq.heappush(self._queuq, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queuq)[-1]


q = PriorityQueue()
q.push("A", 1)
q.push("B", 5)
q.push("C", 4)
q.push("D", 1)
print(q.pop())  # B
print(q.pop())  # C
print(q.pop())  # A
print(q.pop())  # D
```
可以观察到，拥有相同优先级的元素（A 和 B）返回的顺序和插入到队列时的顺序相同，且由于 `push` 和 `pop` 操作的复杂度都是 O(logN)，就算 N（堆中元素的数量）的值很大，操作的效率也很高  
题外话，这里用到了元组的比较大小，**按下标从小到大，一旦比较的结果可以确定，就不会比较剩下的元组元素**


# 在字典中将键映射到多个值上
为了方便创建一个键对应多个值的字典，可以利用 collections 模块中的 defaultdict 类。defaultdict 的一个特点就是会自动初始化第一个值
```
from collections import defaultdict

d = defaultdict(list)
d["a"].append(1)
d["a"].append(2)
d["b"].append(4)
print(d)  # defaultdict(<class 'list'>, {'a': [1, 2], 'b': [4]})
print(d["c"])  # []

d = defaultdict(set)
d["a"].add(1)
d["a"].add(2)
d["b"].add(4)
print(d)  # defaultdict(<class 'set'>, {'a': {1, 2}, 'b': {4}})
print(d["c"])  # set()
```
defaultdict 会自动创建字典表项以待稍后访问（即使这些表项在当前字典中不存在）。如果不想要这个功能，可以在普通的字典上调用 `setdefault()` 方法
```
d = {}
d.setdefault("a", []).append(1)
d.setdefault("a", []).append(2)
d.setdefault("b", {}).add(4)
print(d)  # {'a': [1, 2], 'b': {4}}
```
构建一个一键多值的字典是很容易的，但是试着自己对第一个值做初始化，就会变的很杂乱，用 defaultdict 类或 `setdefault()` 更加优雅


# 让字典保持有序
《Python Cookbook》 是在 Python3.3 的环境下测试的，但是在 3.6 之后 dict 发生了一些变化
> 在 Python3.6 的时候，dict 采用了新的实现方式，相对于之前的内存使用量减少了 20% ~ 25%，并且会保留 key 的排序，但同时官方提示后期可能会变化，所以不应该依赖这一特性  
> 而在 Python3.7 的时候，官方宣布一个特性正式成为 Python 语言规范的一部分，此后所有的 Python 都会遵循这一特性：**字典的key是有序的**  

那么书中提到的，在 3.1 发布的 collections 模块中的 `OrderedDict()` （保留至今 3.10）有什么区别？  
1. OrderedDict 是 dict 的子类，只在有序性上进行了扩展。`move_to_end` 可以将指定的数据，移动到最前或最后，`popitem` 可以选择从最前或最后移除并返回一个数据  
2. OrderedDict 通过增加内存开销的方式（**内部维护一个双向链表，OrderedDict 的大小是 dict 的两倍多**），提供了排序的支持，并通过 `__dict__` 属性，提供更灵活的使用方法。而 dict 的有序，是为了减少性能开销而产生的“额外福利”  

再举一个应用场景的例子，内容相同但排序不一样的相等判断  
```
d1 = dict(a=1, b=2)
d2 = dict(b=2, a=1)
print(d1 == d2)  # True
```
```
from collections import OrderedDict

d1 = OrderedDict(a=1, b=2)
d2 = OrderedDict(b=2, a=1)
print(d1 == d2)  # False
```
```
from collections import OrderedDict

d1 = dict(a=1, b=2)
d2 = OrderedDict(b=2, a=1)
print(d1 == d2)  # True
```
在 dict 中，顺序是个不存在的概念，所以也不会验证顺序。而 OrderedDict 将顺序视为内容的一部分，即使数据一样，但排序不同，也就不相等。但是 OrderedDict 作为 dict 的子类，和 dict 比较时可以看作是两个 dict 进行比较，所以顺序也不做验证  
**综上，如果在某个场景，数据排序是一个重要属性，或者有明确的排序需求，那么就应该使用 OrderedDict 而不是 dict**


# 与字典有关的计算问题
需要在字典上对数据执行各式各样的计算（如最大值、最小值、排序等）。如果仅对字典的值做计算，一般用 `values()` 方法来解决问题。如果涉及到相应的键的关联信息，通常会用 `zip()` 将字典的键值反转，比如以下代码实现了找到年龄最大和最小的学生
```
students = {
    "A": 10,
    "B": 12,
    "C": 11,
    "D": 15,
}

min_student = min(zip(students.values(), students.keys()))
print(min_student)  # (10, 'A')

max_student = max(zip(students.values(), students.keys()))
print(max_student)  # (15, 'D')
```
`zip()` 创建的是一个迭代器，**它的内容只能被消费一次**


# 在两个字典中寻找相同的点
有两个字典，想找出中间可能相同的地方（相同的键、相同的值等），只需通过 `keys()` 或者 `items()` 方法执行常见的集合操作即可
```
a = {"x": 1, "y": 2, "z": 3}
b = {"w": 10, "x": 11, "y": 2}

print(a.keys() & b.keys())  #  {'y', 'x'}
print(a.keys() - b.keys())  #  {'z'}
print(a.items() & b.items())  #  {('y', 2)}
```
字典的 `key()` 会返回一个 keys-view 对象，其中暴露了所有的键，**它们也支持常见的集合操作**，如求并集、交集和差集  
字典的 `items()` 方法返回由 (key, value) 组成的 items-view 对象，这个对象支持类似的集合操作，可用来完成找出两个字典间有哪些键值对有相同之处的操作  
但是，字典的 `values()` 方法并不支持集合操作，部分原因是因为在字典中，从值的角度来看并不能保证所有的值都是唯一的。如果必须要执行这样的操作，还是可以先将值转为集合来实现


# 从序列中移除重复项且保持元素间顺序不变
一般想要去除序列中的重复项，会构建一个集合，但是这种方法不能保证元素间的顺序不变。如果序列中的值是可哈希（如果一个对象是可哈希的，那么在它的生存期内必须是不可变的，它必须有一个 `__hash__()` 方法，整数、浮点数、字符串、元组都是不可变的）的，那么可以通过使用集合和生成器解决
```
def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)


a = [1, 2, 3, 4, 2, 4, 5, 2, 1]
print(list(dedupe(a)))  # [1, 2, 3, 4, 5]
```
只有当序列中的元素是可哈希的时候才能这样做，如果想在不可哈希的对象（比如列表）序列中去除重复项，需要对代码进行修改
```
def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(val)


a = [{"x": 1, "y": 2}, {"x": 1, "y": 3}, {"x": 1, "y": 2}, {"x": 2, "y": 4}]
print(list(dedupe(a, key=lambda d: (d["x"], d["y"]))))  # [{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
print(list(dedupe(a, key=lambda d: d["x"])))  # [{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]
```


# 对切片命名
内置的 `slice()` 函数会创造一个切片对象，可以用在任何允许进行切片操作的地方。如果有一个 slice 对象的实例 s，可以通过 `s.start`、`s.stop` 以及 `s.step` 属性来得到关于该对象的信息
```
s = "HelloWorld"
TEST = slice(5, 8)  # Wor
print(s[TEST])
```  
此外，可以通过 `indices(size)` 的方法将切片映射到特定大小的序列上面，返回一个 (start, stop, step) 元组，所有的值都被限定在边界内（做索引操作时可避免出现 IndexError 异常）
```
s = "HelloWorld"
a = slice(2, 50)
print(a.indices(len(s)))  # (2, 10, 1)
for i in range(*a.indices(len(s))):
    print(s[i])  # l  l  o  W  o  r  l  d
```