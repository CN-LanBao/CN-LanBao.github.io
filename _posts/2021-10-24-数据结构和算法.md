---
title: 数据结构和算法
date: 2021-10-24
categories: 
- Python
tags:
- Python Cookbook
---


根据 《Python Cookbook》 里有趣或自身还不清楚的部分简单总结，以便保存和查找。这将会是一个系列，每个文档对应书中一个章节  

# 从任意长度的可迭代对象中分解元素
用"\*表达式"实现，去掉一个列表中的第一个和最后一个元素，剩下的元素取平均值  
```
def drop_first_last(target):
	first, *middle, last = target
	return avg(middle)
```


# 保存最后 N 个元素
用 `collections.deque` ，`deque(maxlen=N)` 创建了一个固定长度的队列，当队列已满且有新纪录加入，会自动移除最老的那条记录
```
from collections import deque

q = deque(maxlen=3)
for i in range(5):
	q.append(i)
	if i == 2:
		print(q)  # deque([0, 1, 2], maxlen=3)
print(q)  # deque([2, 3, 4], maxlen=3)
```
虽然在列表上也可以手动完成这样的操作（`append`、`del`），但队列这种解决方案更加优雅，且运行速度也快得多  
如果不指定队列的大小，也就得到一个无界限的队列，可以在两端执行添加（`append`、`appendleft`）和弹出（`pop`、`popleft`）操作


# 找到最大或最小的 N 个元素
heapq 模块中有两个函数 `nlargest()` 和 `nsmallest()`
```
import heapq

nums = [1, 8, 7, -5, -27, 66, 34, 23, 0]
print(heapq.nlargest(3, nums))  # [66, 34, 23]
print(heapq.nsmallest(3, nums))  # [-27, -5, 0]
```
这两个函数可以接受一个参数 key，从而工作在更加复杂的数据结构上
```
import heapq

portfolio = [
    {"name": "A", "age": 10},
    {"name": "B", "age": 20},
    {"name": "C", "age": 13},
    {"name": "D", "age": 24},
    {"name": "E", "age": 6},
]
print(heapq.nlargest(3, portfolio, key=lambda s: s["age"]))  # [{'name': 'D', 'age': 24}, {'name': 'B', 'age': 20}, {'name': 'C', 'age': 13}]
print(heapq.nsmallest(3, portfolio, key=lambda s: s["age"]))  # [{'name': 'E', 'age': 6}, {'name': 'A', 'age': 10}, {'name': 'C', 'age': 13}]
```
如果寻找 N 个最大或最小的元素，且同集合中元素的总数目相比，N 很小，那么以下函数可以提供更好的**性能**，这些函数首先在顶层将数据转换成列表，且元素以堆的顺序排列
```
import heapq

nums = [1, 8, 7, -5, -27, 66, 34, 23, 0]
heap = list(nums)
heapq.heapify(heap)
print(heap)  # [-27, -5, 7, 0, 8, 66, 34, 23, 1]
```
堆最重要的特性就是 **`heap[0]` 总是最小那个的元素**。接下来的元素可依次通过 `heapq.heappop()` 找到。该方法会将第一个元素弹出，以第二个元素取而代之（该操作复杂度是 O(logN)，N 代表堆大小）
```
print(heapq.heappop(heap))  # -27
print(heapq.heappop(heap))  # -5
print(heapq.heappop(heap))  # -7
```
当要找的元素数量相对较小时，`nlargest()` 和 `nsmallest()` 是最适用的。如果只是简单地想找到最小或最大的元素，那么用 `max()` 和 `min()` 会更加快。如果 N 和集合本身大小差不多，通常更快的方法是堆集合排序，然后做切片操作（如：`sorted(items)[:N]` 或 `sorted(items)[N:]`）  
另外，`nlargest()` 和 `nsmallest()` 的实际实现会根据使用方式不同，可能会相应做出一些优化措施（如：当 N 的大小同输入大小接近时，就会采用排序的方法）


# 实现优先级队列
利用 heapq 模块实现一个简单的优先级队列，能够以给定的优先级对元素排序，且每次 pop 时都会返回优先级最高的元素
```
import heapq


class PriorityQueue:

    def __init__(self):
        self._queuq = []
        # 插入顺序，将有相同优先级的元素排序
        self._index = 0

    def push(self, item, priority):
    	# 权限越高，相反数越小，位于越前面
        heapq.heappush(self._queuq, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queuq)[-1]


q = PriorityQueue()
q.push("A", 1)
q.push("B", 5)
q.push("C", 4)
q.push("D", 1)
print(q.pop())  # B
print(q.pop())  # C
print(q.pop())  # A
print(q.pop())  # D
```
可以观察到，拥有相同优先级的元素（A 和 B）返回的顺序和插入到队列时的顺序相同，且由于 `push` 和 `pop` 操作的复杂度都是 O(logN)，就算 N（堆中元素的数量）的值很大，操作的效率也很高  
题外话，这里用到了元组的比较大小，**按下标从小到大，一旦比较的结果可以确定，就不会比较剩下的元组元素**


# 在字典中将键映射到多个值上
为了方便创建一个键对应多个值的字典，可以利用 collections 模块中的 defaultdict 类。defaultdict 的一个特点就是会自动初始化第一个值
```
from collections import defaultdict

d = defaultdict(list)
d["a"].append(1)
d["a"].append(2)
d["b"].append(4)
print(d)  # defaultdict(<class 'list'>, {'a': [1, 2], 'b': [4]})
print(d["c"])  # []

d = defaultdict(set)
d["a"].add(1)
d["a"].add(2)
d["b"].add(4)
print(d)  # defaultdict(<class 'set'>, {'a': {1, 2}, 'b': {4}})
print(d["c"])  # set()
```
defaultdict 会自动创建字典表项以待稍后访问（即使这些表项在当前字典中不存在）。如果不想要这个功能，可以在普通的字典上调用 `setdefault()` 方法
```
d = {}
d.setdefault("a", []).append(1)
d.setdefault("a", []).append(2)
d.setdefault("b", {}).add(4)
print(d)  # {'a': [1, 2], 'b': {4}}
```


# 让字典保持有序