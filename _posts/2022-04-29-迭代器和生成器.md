---
title: 迭代器和生成器
date: 2022-04-29
categories: 
- Python
tags:
- Python Cookbook
---


本文对应 《Python Cookbook》 第七章，解决有关迭代中的一些常见问题

# 手动访问迭代器中的元素
处理某个可迭代对象的元素，但不能使用 for 循环，可以使用 `next()` 函数，然后自己处理 `StopIteration` 异常。下面的交互例子对迭代时发生的基本过程做了解释说明
```
items = [1, 2, 3]
it = iter(items)

print(next(it))  # 1

print(next(it))  # 2

print(next(it))  # 3

print(next(it))  # StopIteration
```
一般 `StopIteration` 异常是通知迭代结束的，如果是手动使用 `next()`，也可以令它返回一个结束值，比如 None
```
items = [1, 2, 3]
it = iter(items)

print(next(it, None))  # 1

print(next(it, None))  # 2

print(next(it, None))  # 3

print(next(it, None))  # None
```


# 委托迭代
构建一个自定义容器对象，内部持有其他的可迭代对象，需要让自己的新容器能够完成迭代操作  
一般来说，要做的就是定义一个 `__iter__()` 方法，将迭代请求委托到对象内部持有的容器上
```
class Node(object):

    def __init__(self, value):
        self._value = value
        self._children = []

    # 输出某个实例化对象时，调用的就是该对象的 __repr__() 方法，输出的是该方法的返回值
    def __repr__(self):
        # !r 自动转义
        return "Node({!r})".format(self._value)

    def add_child(self, node):
        self._children.append(node)

    def __iter__(self):
        return iter(self._children)


if __name__ == '__main__':
    root = Node(0)
    child1, child2 = Node(1), Node(2)
    root.add_child(child1)
    root.add_child(child2)
    for ch in root:
        print(ch)  # Node(1)  Node(2)
```
该例子中，`__iter__()` 方法将迭代请求转发给对象内部持有的 `_children` 属性上  
Python 的迭代协议要求 `__iter__()` 返回一个特殊的迭代器对象，由该对象的 `__next()__` 方法完成实际的迭代。`iter(s)` 通过调用 `s.__iter__()` 来简单地返回底层的迭代器，这个 `len(s)` 调用 `s.__len__()` 的方式是一样的


# 用生成器创建新的迭代模式
实现一个自定义的迭代模式，区别于常见的内建函数（`range()`、`reversed()` 等），可使用生成器函数来定义。以下的例子构建了一个可产生某个范围内的浮点数的生成器
```
def frange(start, stop, increment):
    x = start
    while x < stop:
        yield x
        x += increment


for i in frange(0, 4, 0.5):
    print(i)  # 0  0.5  1.0  1.5  2.0  2.5  3.0  3.5

print(list(frange(0, 1, 0.125)))  # [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875]

```
函数里只要出现了 `yield` 语句就会将其转变成一个生成器，生成器只会在响应迭代操作时才运行


# 实现迭代协议
构建一个自定义对象，支持迭代操作，用一种简单的方式实现迭代协议，比如生成器函数  
以下例子实现了一个迭代器能够以深度优先的模式遍历树节点
```
class Node(object):

    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return "Node({!r})".format(self._value)

    def add_child(self, node):
        self._children.append(node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()


if __name__ == '__main__':
    root = Node(0)
    child1, child2 = Node(1), Node(2)
    root.add_child(child1)
    root.add_child(child2)

    child1.add_child(Node(3))
    child1.add_child(Node(4))
    child2.add_child(Node(5))

    for ch in root.depth_first():
        print(ch)  # Node(0)  Node(1)  Node(3)  Node(4)  Node(2)  Node(5)
```
`depth_first()` 首先产生自身，然后迭代每个子节点，利用子节点的 `depth_first()` 方法（通过 `yield from` 语句）产生其他元素  
Python 的迭代协议要求 `__iter__()` 返回一个特殊的迭代器对象，该对象必须实现 `__next__()` 方法，并使用 `StopIteration` 异常来通知迭代的完成。但实现这样的对象比较繁琐，因为迭代器必须维护迭代过程中许多复杂的状态。把迭代器以生成器的形式来定义就皆大欢喜了（生成器函数自动实现了迭代器协议）


# 反向迭代
