---
title: 类与对象
date: 2022-05-13
categories: 
- Python
tags:
- Python Cookbook
---


本文对应 《Python Cookbook》 第八章，内容包括让对象支持常见的 Python 特性、特殊方法的使用、封装、继承、内存管理及一些有用的设计模式

#  修改实例的字符串表示
想修改打印实例产生的输出，使输出结果更有意义，可通过定义 `__str__()` 和 `__repr__()` 方法来实现
```
class Author(object):

    def __init__(self, name, age):
        self.name, self.age = name, age

    def __repr__(self):
        return "Author({0.name!r}, {0.age!r})".format(self)

    def __str__(self):
        return "({0.name!s}, {0.age!s})".format(self)

```

特殊方法 `__repr__()` 返回的是实例的代码表示（code representation），通常可以用它返回的字符串文本重新创建这个实例，即满足 `obj == eval(repr(obj))`。内建的 `repr()` 函数可以返回这个字符串  
特殊方法 `__str__()` 将实例转换为一个字符串，这也是 `str()` 和 `print()` 函数所产生的输出  
特殊的格式化代码 `!r` 表示应该使用 `__repr__()` 的输出，而不是默认的 `__str__()`  
对于 `__repr__()`，标准的做法是让他产生的字符串文本满足 `obj == eval(repr(obj))`，如果不可能办到或不希望这样，通常让它产生一段有帮助意义的文本，并且以 < 和 > 括起来
```
with open("text1", "r") as f:
    print(repr(f))  # <_io.TextIOWrapper name='text1' mode='r' encoding='UTF-8'>
```


# 自定义字符串的输出格式
想让对象通过 `format()` 函数和字符串方法来支持自定义的输出格式，可以在类中定义 `__format__()` 方法
```
_formats = {
    "ymd": "{d.year}-{d.month}-{d.day}",
    "mdy": "{d.month}/{d.day}/{d.year}",
    "dmy": "{d.day}/{d.month}/{d.year}",
}


class Date(object):

    def __init__(self, year, month, day):
        self.year, self.month, self.day = year, month, day

    def __format__(self, code):
        if code == "":
            code = "ymd"
        fmt = _formats[code]
        return fmt.format(d=self)


d = Date(2022, 5, 13)
print(format(d, "ymd"))  # 2022-5-13
print("The date is {}".format(d, "mdy"))  # The date is 2022-5-13
print("The date is {:dmy}".format(d))  # The date is 13/5/2022

```

`__format__()` 方法在 Python 的字符串格式化功能中提供了一个钩子，对格式化代码的解释完全取决于类本身，因此格式化代码几乎可以为任何形式


# 让对象支持上下文管理协议
要让对象支持上下文管理协议（context-management protocol，通过 `with` 语句触发），需要实现 `__enter__()` 和 `__exit__()` 方法
```
class Author(object):

    def __init__(self, name="CN-LanBao", age=23):
        self.name, self.age = name, age
        self.mood = None
        print("init finish")

    def __enter__(self):
        print("I am enter")
        self.mood = "blue"
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.mood = None
        print("I am exit")


with Author() as a:
    # __enter__ print("I am enter")
    print("My mood is", a.mood)  # My mood is blue
    # __exit__ print("I am exit")
print("END")

```
上下文管理器最常用于管理类似**文件、网络连接和锁**这样的资源的程序中，这些资源的关键点在于它们必须显式地进行关闭或释放才能正常工作  
当遇到 `with` 语句时，`__enter__()` 方法首先被触发，`__enter__()` 如果有返回值，则被放置在 `as` 限定的变量中，之后执行 `with` 代码块中语句，最后触发 `__exit__()` 方法执行清理工作  
这种形式的控制流和 with 语句中发生的情况没有关联，**出现异常也是如此**。`__exit__()` 方法的三个参数就包含了异常类型、值、和对挂起异常的追溯（如果出现异常）。`__exit__()` 方法可以选择以某种方式来使用异常信息，或者什么也不做直接返回 None 作为结果。**如果返回 True，异常就会被清理干净，**程序也会立刻继续执行 with 语句块之后的代码  


# 当创建大量实例时如何节省内存
对于主要用作简单数据结构的类，通常可以在类中增加 `__solt__` 属性，来大量减少对内存的使用
```
class Author(object):

    __slots__ = ["name", "age"]

    def __init__(self, name="CN-LanBao", age=23):
        self.name, self.age = name, age
        self.mood = None


a = Author()  # AttributeError: 'Author' object has no attribute 'mood'
```
当定义了 `__slot__` 属性，Python 会针对实例采用一种更加紧凑的内部展示，不再让每个实例都创建一个 `__dict__` 字典，而是围绕着一个固定长度的小型数组来构建。`__slot__` 中列出的属性名会在内部映射到这个数组的特定索引上，副作用是 **没法再对实例添加任何新的属性**  
使用 `__slot__` 节省下来的内存根据创建的实例数量和保存的属性类型有所不同，一般来说使用的内存量相当于将数据保存在元组中  
**大部分代码中都应该尽量避免使用 `__slot__`，**因为 Python 中许多部分都依赖传统的基于字典的实现。此外，定义了 `__slot__` 的类不支持某些特定功能，如多重继承。**我们应该只对被当作数据结构而频繁使用的类上使用**


# 将名称封装到类中
将“私有”属性封装到类的示例上，但是又要考虑 Python 缺乏对属性的访问控制问题  
Python 程序更期望通过特定命名规则来表达数据和方法的用途，单下划线开头总是被认为只属于内部实现。  
双下划线开头的名称会导致出现名称重整（name mangling）的行为，私有属性会被重命名为 `_类名__属性`，这样的属性不能通过继承而覆盖  
对于大部分代码而言，应该让非共有名称以单下划线开头。但是若代码中设计子类化处理，而且这些属性需要对子类隐藏，那么就应该使用双下划线开头  
**此外，有时候想定义一个变量，但是名称可能和保留字产生冲突，基于此，应该在名称最后加上一个单下划线以示区别**
```
id_ = 1
```


# 创建可管理的属性
在对实例属性的获取和设定上，希望增加一些额外的处理过程（如类型检查或验证）  
一种简单的方式是将其定义为 property （把类中定义的函数当作一种属性来使用）
```
class Author(object):

    def __init__(self, name="CN-LanBao"):
        self.name = name

    # Getter function
    @property
    def name(self):
        print("Getter: name")
        return self._name

    @name.setter
    def name(self, value):
        print("Setter: name")
        if not isinstance(value, str):
            raise TypeError("Expected a string")
        self._name = value

    @name.deleter
    def name(self):
        print("Deleter: name")
        raise AttributeError("Can not delete attribute")

```
上述代码一共有三个相互关联的方法，必须有相同的名称。第一个方法是一个 getter 函数，并且将 name 定义为 property 属性。其他两个方法将可选的 setter 和 deleter 函数附加到了 name 属性上。注意，除非 name 已经通过 `@property` 的方式定义为了 property 属性，否则是不能定义 `@name.setter` 和 `@name.deleter` 装饰器的  
property 的重要特性就是它看起来像一个普通的属性，但是根据访问它的不同方式，会自动触发 getter、setter 和 deleter 方法
```
a = Author()
print(a.name)  # Setter: name  Getter: name  CN-LanBao

a.name = 0  # Setter: name  TypeError: Expected a string

del a.name  # Deleter: name  AttributeError: Can not delete attribute

```