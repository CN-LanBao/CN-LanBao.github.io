---
title: 函数
date: 2022-06-08
categories: 
- Python
tags:
- Python Cookbook
---


本文对应 《Python Cookbook》 第七章，展示一些更加高级和独特的函数定义及使用模式  


# 编写只接受关键字参数的函数
希望函数只通过关键字的形式接受特定的参数，可以通过将关键字参数放置在 `*` 打头的参数，或者是一个单独的 `*` 之后实现（`*` 打头的参数只能作为**最后一个位置参数**出现，`**` 打头的参数只能作为**最后一个参数**出现。在 `*` 打头的参数后，仍然可以有其他参数（keyword-only 参数）出现，这些参数只能作为关键字参数使用）
```
def deposit(*money, name):
    print(name, "has", sum(money))


deposit(10, 20, 5, name="CN-LanBao")  # CN-LanBao has 35

```
```
def test(*, name):
    print(name)


test(name="CN-LanBao")  # CN-LanBao
test("CN-LanBao")  # TypeError: test() takes 0 positional arguments but 1 was givens

```


# 定义带有默认参数的函数
定义一个函数或者方法，其中有一个或多个参数是可选的并且带有默认值  
表面上看只需要在定义中为参数复制
```
def test(a, b="b"):
    print(a, b)

```
如果不打算提供默认值，只是想检查可选参数是否被赋予了某个特定值，可以采用下面的方法
```
_no_value = object()


def test(a, b=_no_value):
    if b is _no_value:
        print("b is not supplied")

```
该方法非常巧妙，因为有一个非常棘手的问题，不能使用 None、0 或 False 当作默认值来检测用户是否提供了参数（**需仔细区分不传递任何值和传递 None 之间的区别**  ），因为这些都是合法的参数。这里利用 `object()` 创建独特的私有实例，这里主要考虑用户把 `_no_value` 作为参数几乎不可能，所以是一个可以用来安全比较的值（`object()` 没有任何值得注意的方法和实例数据，底层甚至没有 `__dict__` 字典）  
定义带默认参数的函数看起来很简单（在学习本节后半部分前，认为简单，没计划将其总结在本文中），但并非这么简单  
首先，**对默认参数的赋值只会在函数定义的时候绑定一次**
```
x = 181


def test(a, b=x):
    print(a, b)


test(1)  # 1 181
x = 125
test(1)  # 1 181

```
即便修改变量 `x` 的值，也没有对函数产生任何效果，因为默认值在函数定义的时候已经确定了  
其次，给默认参数赋值的应该总是**不可变对象**，如 None，bool，数字或字符串
```
def test(a, b=[]):
    print(b)
    return b


x = test(1)  # []
x.append("CN-LanBao")
y = test(1)  # ["CN-LanBao"]

```
这很可能不是预期的结果，为了避免该问题，用 None 作为默认值，并在函数体中增加一个对默认值的检查



# 让带有 N 个参数的可调用对象以较少的参数形式调用
有一个可调用对象可能会以回调函数（A callback is a function that is passed as an argument to another function and is executed after its parent function has completed）的形式同其他 Python 代码交互，但是需要的参数过多，直接调用会产生异常  
`functools.partial()` 可以用来减少函数的参数数量。`partial()` 允许给一个或多个参数指定固定的值，以此减少需要提供给之后调用的参数数量
```
from functools import partial


def test(a, b, c, d):
    print(a, b, c, d)


t1 = partial(test, "CN-LanBao")
t1(23, 181, 125)  # CN-LanBao 23 181 125

t2 = partial(t1, d=125)
t2(12, 181)  # CN-LanBao 23 181 125

t3 = partial(t2, 12, 181)
t3()  # CN-LanBao 12 181 125

```
`partial()` 对特定的参数赋固定值并返回全新的可调用对象，其将传给 `partial()` 的固定参数结合起来，统一将所有参数传递给原始的函数  
`partial()` 用于将看似不兼容的代码结合起来很有用
```
import math
from functools import partial


def distance(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    return math.hypot(x2 - x1, y2 - y1)


points = [(1, 2), (2, 3), (4, 6)]
pt = (4, 3)

points.sort(key=partial(distance, pt))
print(points)  # [(2, 3), (4, 6), (1, 2)]

points.sort(key=lambda p: distance(pt, p))
print(points)  # [(2, 3), (4, 6), (1, 2)]

```
想要根据 `points` 中各点与 `pt` 的距离排序，列表的 `sort()` 方法可以接受一个 key 参数，用来做自定义的排序处理。但是只能和接受单参数的函数一起工作（因此和 `distance()` 不兼容），所以用 `partial()` 解决。虽然 lambda 也能实现，但是显得很啰嗦，令人困惑